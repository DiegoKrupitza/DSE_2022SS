\section{Frameworks und Bibliotheken}

In diesem Kapitel werden die verwendeten Frameworks und Bibliotheken kurz beschrieben.
Detaillierte Informationen können den Dokumentationen der jeweiligen Projekte entnommen werden.

\subsection{Entity-Service und Tracking-Service}

Sowohl der Entity-Service als auch der Tracking-Service wurden mithilfe des \href{https://www.fastify.io}{Fastify-Frameworks} entwickelt.
Dabei handelt es sich um ein Web-Framework für Node.js, welches sich durch seine hohe Performanz sowie Schema-Vali\-dierung auszeichnet.

Für die Kommunikation mit der MongoDB Datenbank wird die offizielle Bibliothek \href{https://github.com/mongodb/node-mongodb-native}{node-mongodb-native} verwendet.

Die Kommunikation mit der \enquote{MoM} basiert auf der Bibliothek \href{https://amqp-node.github.io/amqplib/}{amqplib}.

Darüber hinaus wird \href{https://github.com/motdotla/dotenv}{dotenv} zum Laden der Umgebungsvariablen verwendet.

\subsection{Cockpit}

Für die Entwicklung des Frontends wurde eine Vielzahl and Bibliotheken eingesetzt.
Die Grundlage bildet das Framework \href{https://vuejs.org}{Vue 3}.
In Kombination mit dem Build-Tool \href{https://vitejs.dev}{Vite}, bietet Vue 3 eine moderne Entwicklungsumgebung und beschleunigt die Umsetzung der Anforderungen durch nützliche Funktionen wie beispielsweise Hot-Reloads in wenigen Millisekunden.

Darüber hinaus wurde \href{https://formkit.com}{FormKit} eingesetzt um eine Validierung von Nutzereingaben zu vereinfachen.

\href{https://github.com/axios/axios}{Axios} wurde als zuverlässiger HTTP-Client in das Frontend eingebunden, um eine Kommunikation mit dem Backend umzusetzen.

Die Bibliothek \href{https://github.com/Maronato/vue-toastification}{vue-toastification} kommt beim Anzeigen von Statusmelden, beispielsweise beim Starten und Stoppen von Simulationen, zum Einsatz.

Als performantere Alternative zu Tailwind wurde die Bibliothek \href{https://uno.antfu.me}{UnoCSS} verwendet.

\subsection{Flowcontrol-Service}
Für die Entwicklung des Simulator-Services, welches in Java entwickelt wurde, wurde auf das Spring Boot gesetzt sowie Spring Cloud gesetzt. Damit die Kommunikation über REST mit den anderen Services nicht viel unnötigen boilerplate Code braucht, verwenden wir \\ \verb|org.springframework.cloud : spring-cloud-starter-feign| eine Implementation von OpenFeign. Da dieses Service auch mit RabbitMQ kommuniziert verwenden wir auch die Implementierung von \verb|spring-boot-starter-amqp|. Dies ermöglichte uns sehr schnell mit wenig Code effizient mit der RabbitMQ Instanz zu kommunizieren. Für das Testen wurde JUnit5 und TestContainer verwendet.

\subsection{Simulator-Service}
Für die Entwicklung des Simulator-Services, welches in Java entwickelt wurde, wurde auf das Spring Boot gesetzt sowie Spring Cloud gesetzt. Für die Entwicklung der Restcontroller wurde unter anderem Spring MVC verwendet. Damit die Kommunikation über REST mit den anderen Services nicht viel unnötigen boilerplate Code braucht, verwenden wir \\ \verb|org.springframework.cloud : spring-cloud-starter-feign| eine Implementation von OpenFeign. Da dieses Service auch mit RabbitMQ kommuniziert verwenden wir auch die Implementierung von \verb|spring-boot-starter-amqp|. Dies ermöglichte uns sehr schnell mit wenig Code effizient mit der RabbitMQ Instanz zu kommunizieren. Für das Testen wurde JUnit5 verwendet.

\subsection{Gateway-Service}
Für die Entwicklung des Gateways wurde auf das Spring Boot gesetzt sowie Spring Cloud gesetzt. Für die Umsetzung vom Gateway war insbesondere die Dependency \verb|org.springframework.cloud : spring-cloud-starter-gateway| sehr von Bedeutung, da dies uns erlaubt hat mit möglichst wenig aufwand und nur durch reine Konfiguration ein sehr gutes Gateway aufzusetzen.
