\section{Frameworks und Bibliotheken}

In diesem Kapitel werden die verwendeten Frameworks und Bibliotheken kurz beschrieben.
Detaillierte Informationen können den Dokumentationen der jeweiligen Projekte entnommen werden.

\subsection{Entity-Service und Tracking-Service}

Sowohl der Entity-Service als auch der Tracking-Service wurden mithilfe des \href{https://www.fastify.io}{Fastify-Frameworks} entwickelt.
Dabei handelt es sich um ein Web-Framework für Node.js, welches sich durch seine hohe Performanz sowie Schema-Vali\-dierung auszeichnet.

Für die Kommunikation mit der MongoDB Datenbank wird die offizielle Bibliothek \href{https://github.com/mongodb/node-mongodb-native}{node-mongodb-native} verwendet.

Die Kommunikation mit der \enquote{MoM} basiert auf der Bibliothek \href{https://amqp-node.github.io/amqplib/}{amqplib}.

Darüber hinaus wird \href{https://github.com/motdotla/dotenv}{dotenv} zum Laden der Umgebungsvariablen verwendet.

\subsection{Cockpit}

Für die Entwicklung des Frontends wurde eine Vielzahl and Bibliotheken eingesetzt.
Die Grundlage bildet das Framework \href{https://vuejs.org}{Vue 3}.
In Kombination mit dem Build-Tool \href{https://vitejs.dev}{Vite}, bietet Vue 3 eine moderne Entwicklungsumgebung und beschleunigt die Umsetzung der Anforderungen durch nützliche Funktionen wie beispielsweise Hot-Reloads in wenigen Millisekunden.

Darüber hinaus wurde \href{https://formkit.com}{FormKit} eingesetzt um eine Validierung von Nutzereingaben zu vereinfachen.

\href{https://github.com/axios/axios}{Axios} wurde als zuverlässiger HTTP-Client in das Frontend eingebunden, um eine Kommunikation mit dem Backend umzusetzen.

Die Bibliothek \href{https://github.com/Maronato/vue-toastification}{vue-toastification} kommt beim Anzeigen von Statusmelden, beispielsweise beim Starten und Stoppen von Simulationen, zum Einsatz.

Als performantere Alternative zu Tailwind wurde die Bibliothek \href{https://uno.antfu.me}{UnoCSS} verwendet.

\subsection{Flowcontrol-Service}

Für die Entwicklung des Flowcontrol-Services, welcher in Java implement wurde, wurden Spring Boot sowie Spring Cloud eingesetzt.
Damit die REST-Kommunikation mit den anderen Services nur minimalen Boilerplate-Code aufweist, wurde mit \\ \verb|org.springframework.cloud : spring-cloud-starter-feign| eine Implementierung von OpenFeign verwendet.
Da dieser Service auch mit RabbitMQ kommuniziert, wurde zudem \verb|spring-boot-starter-amqp| eingebunden.
Dies ermöglichte uns eine simple Anbindung von mit RabbitMQ Instanzen für eine asynchrone Kommunikation.
Zum Testen wurden JUnit5 sowie TestContainer verwendet.

\subsection{Simulator-Service}

Für die Entwicklung des Simulator-Services, welcher in Java implementiert wurde, wurden Spring Boot, Spring Cloud sowie Spring MVC eingesetzt.
Damit die REST-Kommunikation mit den anderen Services nur minimalen Boilerplate-Code aufweist, wurde mit \\ \verb|org.springframework.cloud : spring-cloud-starter-feign| eine Implementierung von OpenFeign verwendet.
Da dieser Service auch mit RabbitMQ kommuniziert, wurde zudem \verb|spring-boot-starter-amqp| eingebunden.
Dies ermöglichte uns eine simple Anbindung von mit RabbitMQ Instanzen für eine asynchrone Kommunikation.
Zum Testen wurden JUnit5 sowie TestContainer verwendet.

\subsection{Gateway-Service}

Für die Entwicklung des Gateway-Services, welcher in Java implement wurde, wurden Spring Boot sowie Spring Cloud eingesetzt.
Insbesondere die Bibliothek \verb|org.springframework.cloud : spring-cloud-starter-gateway| war für die Umsetzung vom Gateway von Bedeutung, da diese das Erstellen eines Gateways auf Basis einer Konfigurationsdatei ermöglicht.
